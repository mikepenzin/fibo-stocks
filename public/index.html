<!doctype html>
<html lang="en" data-bs-theme="auto">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stocks 1D Analyzer (Node)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body{padding-block:24px}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    canvas{border:1px solid var(--bs-border-color); border-radius:.5rem; width:100%; height:auto}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:.25rem .75rem}
    .kv .k{color:var(--bs-secondary-color)}
    .fib-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:.5rem}
    /* Enforce uppercase visually in the ticker input */
    #ticker.ticker-input{ text-transform: uppercase; }
    /* Custom autocomplete dropdown styling */
    #suggestBox.list-group { border: 1px solid #b6b6b6; box-shadow: 0 2px 8px #0001; background: #fff; }
    #suggestBox .autocomplete-item {
      display: flex; flex-direction: column; align-items: flex-start; padding: 8px 12px; border-bottom: 1px solid #f0f0f0; background: #fff; cursor: pointer; transition: background 0.15s;
    }
    #suggestBox .autocomplete-item:last-child { border-bottom: none; }
    #suggestBox .autocomplete-item:hover, #suggestBox .autocomplete-item.active { background: #f3f6fa; }
    #suggestBox .ac-symbol { font-weight: bold; font-size: 1.15em; color: #1a237e; letter-spacing: 1px; }
    #suggestBox .ac-type { font-size: 0.85em; margin-left: 8px; background: #e3e6ee; color: #333; border-radius: 6px; padding: 2px 7px; font-weight: 500; }
    #suggestBox .ac-name { color: #444; font-size: 0.98em; margin-top: 2px; }
    #suggestBox .ac-exch { color: #888; font-size: 0.85em; margin-top: 1px; }
    .metric-good{color:#198754;font-weight:500}
    .metric-warn{color:#ffc107;font-weight:500}
    .metric-bad{color:#dc3545;font-weight:500}
    .insight-box{background:var(--bs-light-bg-subtle,#f8f9fa);border:1px dashed var(--bs-border-color);padding:.5rem .75rem;border-radius:.5rem}
  </style>
</head>
<body>
<div class="container">
  <header class="mb-3">
    <h1 class="h4 mb-1">üìà Stocks Analyzer</h1>
    <div class="text-secondary small">Express API + Bootstrap ‚Ä¢ Data: Yahoo Finance ‚Ä¢ Timeframe: <span id="headerTimeframe">1D</span> ‚Ä¢ MA: <span id="headerMABasis">20/50</span></div>
  </header>

  <div class="card shadow-sm mb-3">
    <div class="card-body">
      <form id="form" class="row g-2 align-items-center">
        <div class="col-auto"><label for="ticker" class="col-form-label">Ticker</label></div>
        <div class="col-auto position-relative">
          <input id="ticker" class="form-control ticker-input" placeholder="e.g. NVDA, AAPL" required autocomplete="off" list="tickerList">
          <!-- <div id="suggestBox" class="position-absolute bg-body border rounded shadow-sm w-100 mt-1 d-none" style="z-index:1000; max-height: 260px; overflow:auto;"></div> -->
          <datalist id="tickerList"></datalist>
        </div>
        <div class="col-auto form-check ms-2">
          <input class="form-check-input" type="checkbox" id="showChart" checked>
          <label class="form-check-label" for="showChart">Show chart</label>
        </div>
        <div class="col-auto">
          <select id="range" class="form-select form-select-sm" style="min-width:110px">
            <option value="1d" selected>1 Day</option>
            <option value="1h">1 Hour</option>
            <option value="15m">15 Minutes</option>
            <option value="5m">5 Minutes</option>
            <option value="1w">1 Week</option>
          </select>
        </div>
        <div class="col-auto">
          <select id="maBasis" class="form-select form-select-sm" title="MA pair" style="min-width:110px">
            <option value="20-50" selected>MA20/50</option>
            <option value="50-150">MA50/150</option>
          </select>
        </div>
        <div class="col-auto"><button id="go" class="btn btn-primary" type="submit">Analyze</button></div>
        <div class="col-auto"><span id="spin" class="spinner-border spinner-border-sm text-primary d-none"></span></div>
      </form>
    </div>
  </div>

  <div id="alert" class="alert alert-danger d-none" role="alert"></div>

  <div class="row g-3 mb-3">
    <div class="col-12 mb-2 d-flex justify-content-end gap-2">
      <button id="backtestBtn" class="btn btn-outline-warning btn-sm">Backtest Fib</button>
      <button id="downloadImg" class="btn btn-outline-primary btn-sm">Download as Image</button>
      <button id="copyImg" class="btn btn-outline-secondary btn-sm">Copy Result to Clipboard</button>
    </div>
    <div class="col-lg-6">
      <div id="panel" class="card shadow-sm d-none h-100">
        <div class="card-body">
          <div class="d-flex flex-wrap align-items-center justify-content-between">
            <div class="h5 mb-0" id="title"></div>
            <div class="d-flex align-items-center gap-2">
              <span id="tfBadge" class="badge text-bg-secondary">1D</span>
              <span id="expBadge" class="badge d-none"></span>
            </div>
          </div>
          <hr class="my-3">
          <div class="kv small">
            <div class="k" title="Last traded price">Price</div><div class="v" id="price"></div>
            <div class="k" title="Overall directional structure based on selected MA pair">Trend</div><div class="v" id="trend"></div>
            <div class="k" title="Relative Strength Index (14)">RSI(14)</div><div class="v" id="rsi"></div>
            <div class="k" title="Commodity Channel Index (14)">CCI(14)</div><div class="v" id="cci"></div>
            <div class="k" title="Average True Range (14)">ATR(14)</div><div class="v" id="atr"></div>
            <div class="k" title="ATR as % of price">ATR %</div><div class="v" id="atrpct"></div>
            <div class="k" title="Volume vs 20 period moving average">Vol Œî vs 20d</div><div class="v" id="vold"></div>
            <div class="k" title="Next earnings date distance">Earnings</div><div class="v" id="earn"></div>
          </div>
          <div id="insight" class="insight-box small mt-2 d-none"></div>
          <hr>
          <div class="mb-1 fw-semibold">Trade plan</div>
          <div class="kv">
            <div class="k" title="Directional bias + confidence stars">Bias</div><div class="v" id="bias"></div>
            <div class="k" title="Suggested entry level">Entry</div><div class="v mono" id="entry"></div>
            <div class="k" title="Protective stop">Stop Loss</div><div class="v mono" id="sl"></div>
            <div class="k" title="First profit target">TP1</div><div class="v mono" id="tp1"></div>
            <div class="k" title="Second profit target / stretch">TP2</div><div class="v mono" id="tp2"></div>
          </div>
          <!-- <div class="mt-2 small" id="sizingBox">
            <div class="input-group input-group-sm" title="Position sizing helper">
              <span class="input-group-text">$ Risk</span>
              <input id="riskUsd" type="number" class="form-control" placeholder="100" min="0" step="10">
              <button id="calcSize" class="btn btn-outline-secondary" type="button">Size</button>
            </div>
            <div class="mt-1" id="sizeOut"></div>
          </div> -->
          <hr>
          <div class="mb-1 fw-semibold">Fibonacci levels (auto swing)</div>
          <div class="fib-grid small mono" id="fibs"></div>
          <div id="btSection" class="mt-3 d-none">
            <div class="fw-semibold mb-1">Backtest (recent swings)</div>
            <div class="small" id="btStats"></div>
            <div class="table-responsive small mt-2">
              <table class="table table-sm table-bordered align-middle mb-0">
                <thead class="table-light"><tr><th>Date</th><th>Entry(50%)</th><th>Target(38.2%)</th><th>Stop(61.8%)</th><th>Outcome</th></tr></thead>
                <tbody id="btRows"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-6">
      <div id="chartCard" class="card shadow-sm d-none h-100">
        <div class="card-body">
          <div class="d-flex flex-wrap align-items-center justify-content-between gap-2">
            <div class="fw-semibold">Chart (OHLC + Fib)</div>
            <div class="d-flex align-items-center gap-2">
              <select id="flowMetric" class="form-select form-select-sm" title="Flow metric">
                <option value="OBV" selected>OBV</option>
                <option value="MFI">MFI</option>
                <option value="CMF">CMF</option>
              </select>
              <!-- <button id="savePng" class="btn btn-outline-secondary btn-sm">Save PNG</button> -->
            </div>
          </div>
          <canvas id="chart" width="980" height="420" class="mt-2 chart-canvas"></canvas>
          <div class="d-flex justify-content-between align-items-center mt-3">
            <div class="fw-semibold small" id="flowTitle">Flow: OBV + Price</div>
          </div>
          <canvas id="flowChart" width="980" height="200" class="mt-2 chart-canvas"></canvas>
          <div class="d-flex justify-content-between align-items-center mt-3">
            <div class="fw-semibold small">Support/Resistance Levels</div>
          </div>
          <canvas id="srChart" width="980" height="180" class="mt-2 chart-canvas"></canvas>
          <div class="small text-secondary mt-2">Lightweight canvas rendering (price + selectable flow metric + S/R levels).</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast container -->
  <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 1100">
    <div id="mainToast" class="toast align-items-center text-bg-primary border-0" role="alert" aria-live="assertive" aria-atomic="true">
      <div class="d-flex">
        <div class="toast-body" id="toastMsg">Copied to clipboard!</div>
        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
    </div>
  </div>

  <footer class="mt-4 text-secondary small">
     Made with ‚ù§Ô∏è by <a href="https://github.com/mikepenzin/fibo-stocks">Mike Penzin</a>
  </footer>

  <!-- Fullscreen Chart Modals (separate) -->
  <div class="modal fade" id="priceModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen-md-down modal-xl" style="max-width:95vw;">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Price Chart</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="small text-secondary mb-2" id="priceModalMeta"></div>
          <canvas id="priceModalCanvas" width="1400" height="640" class="w-100 border rounded"></canvas>
        </div>
        <div class="modal-footer">
          <button class="btn btn-outline-secondary btn-sm" id="priceModalSave">Save PNG</button>
          <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>
  <div class="modal fade" id="flowModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen-md-down modal-xl" style="max-width:95vw;">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Flow Chart</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <canvas id="flowModalCanvas" width="1400" height="320" class="w-100 border rounded"></canvas>
        </div>
        <div class="modal-footer">
          <button class="btn btn-outline-secondary btn-sm" id="flowModalSave">Save PNG</button>
          <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>
  <div class="modal fade" id="srModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen-md-down modal-xl" style="max-width:95vw;">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Support / Resistance</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <canvas id="srModalCanvas" width="1400" height="320" class="w-100 border rounded"></canvas>
        </div>
        <div class="modal-footer">
          <button class="btn btn-outline-secondary btn-sm" id="srModalSave">Save PNG</button>
          <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
const $ = s=>document.querySelector(s);
const show = (el, v)=>el.classList.toggle('d-none', !v);
const pct = (x,d=2)=>Number.isFinite(x)?((x>=0?'+':'')+x.toFixed(d)+'%'):'n/a';
const fmt = (x,d=2)=>Number.isFinite(x)?Number(x).toFixed(d):'n/a';
function clearBacktest(){
  const s=document.getElementById('btSection'); if(!s) return;
  s.classList.add('d-none');
  const st=document.getElementById('btStats'); if(st) st.textContent='';
  const rows=document.getElementById('btRows'); if(rows) rows.innerHTML='';
}

// Uppercase + autocomplete for ticker input via backend proxy
const tickerEl = $('#ticker');
const boxEl = $('#suggestBox');
const listEl = $('#tickerList');
function upperSanitize(v){ return v.toUpperCase().replace(/[^A-Z0-9\.\-]/g,''); }
function showBox(show){ if(!boxEl) return; boxEl.classList.toggle('d-none', !show); }
function renderSuggestions(items){
  // Populate native datalist too (fallback / native dropdown)
  if (listEl) {
    const opts = (items||[]).map(it => {
      const lbl = `${(it.name||'').replace(/</g,'&lt;')} ${it.exch?`(${it.exch})`:''}`.trim();
      return `<option value="${it.symbol}" label="${lbl}"></option>`;
    }).join('');
    listEl.innerHTML = opts;
  }
  if(!boxEl) return;
  if(!items?.length){ boxEl.innerHTML=''; showBox(false); return; }
  boxEl.innerHTML = items.map(it=>
    `<div class="autocomplete-item" data-sym="${it.symbol}">
      <div><span class="ac-symbol">${it.symbol}</span>${it.type ? `<span class="ac-type">${it.type}</span>` : ''}</div>
      <div class="ac-name">${(it.name||'').replace(/</g,'&lt;')}</div>
      <div class="ac-exch">${it.exch||''}</div>
    </div>`
  ).join('');
  boxEl.classList.add('list-group');
  showBox(true);
  boxEl.querySelectorAll('[data-sym]').forEach(btn=>{
    btn.addEventListener('click',()=>{ tickerEl.value = btn.dataset.sym; showBox(false); tickerEl.focus(); });
  });
}
let suggestTimer;
async function fetchSuggestions(q){
  try{
    const r = await fetch(`/api/suggest?q=${encodeURIComponent(q)}`, { cache:'no-store' });
    const j = await r.json();
    if(!j.ok) return renderSuggestions([]);
    renderSuggestions(j.results||[]);
  }catch(e){ renderSuggestions([]); }
}
if (tickerEl) {
  tickerEl.addEventListener('input',(e)=>{
    const pos = e.target.selectionStart;
    e.target.value = upperSanitize(e.target.value);
    try{ e.target.setSelectionRange(pos,pos); }catch{}
    clearTimeout(suggestTimer);
    const v = e.target.value.trim();
    if (!v){ showBox(false); return; }
    suggestTimer = setTimeout(()=>fetchSuggestions(v), 150);
  });
  tickerEl.addEventListener('blur',()=> setTimeout(()=>showBox(false), 150));
  tickerEl.addEventListener('focus',()=>{ if (tickerEl.value) fetchSuggestions(tickerEl.value); });
}

// Update header timeframe when dropdown changes
const rangeEl = document.getElementById('range');
if (rangeEl) {
  rangeEl.addEventListener('change', (e) => {
    const headerTimeframe = document.getElementById('headerTimeframe');
    if (headerTimeframe) headerTimeframe.textContent = e.target.value.toUpperCase();
    const tfBadge = document.getElementById('tfBadge');
    if (tfBadge) tfBadge.textContent = e.target.value.toUpperCase();
    clearBacktest();
  });
}
// Update header MA basis when changed
const maBasisEl = document.getElementById('maBasis');
if (maBasisEl){
  maBasisEl.addEventListener('change', e=>{
    const headerMABasis = document.getElementById('headerMABasis');
    if(headerMABasis) headerMABasis.textContent = e.target.value.replace('-','/');
    clearBacktest();
  });
}

// === Metric classification helpers (added) ===
function classifyRSI(v){ if(!Number.isFinite(v)) return null; return v>70?'metric-warn':v<30?'metric-warn':'metric-good'; }
function classifyATRpct(v){ if(!Number.isFinite(v)) return null; return v>4? 'metric-warn': v<1? 'metric-good': null; }
function classifyVol(v){ if(!Number.isFinite(v)) return null; return v>50? 'metric-good': v<-30? 'metric-bad': null; }
function buildInsight(m){
  if(!m) return '';
  let parts=[];
  if(m.trend==='Uptrend'){ if(m.rsi>70) parts.push('Overbought ‚Äì wait for pullback (Fib 38.2 / 50).'); else parts.push('Healthy uptrend ‚Äì watch 50% retrace for entry.'); }
  else if(m.trend==='Downtrend'){ if(m.rsi<30) parts.push('Oversold ‚Äì bounce risk; target 38.2%.'); else parts.push('Downtrend ‚Äì look for rally to 50% for short.'); }
  else parts.push('Range ‚Äì fade extremes near 61.8% / 38.2%.');
  if(m.vol_delta>60) parts.push('High volume expansion.');
  if(m.atr_pct>4) parts.push('Elevated volatility ‚Äì reduce size.');
  return parts.join(' ');
}
// =============================================

let lastTicker = '';
let lastCandles = null; // store latest candles
let lastFib = null;     // store latest fib levels
let lastMetrics = null; // optional meta
async function analyze(ticker){
  clearBacktest(); // hide old backtest while loading new ticker
  $('#alert').classList.add('d-none');
  $('#spin').classList.remove('d-none');
  try{
    const range = document.getElementById('range').value;
    const maBasis = document.getElementById('maBasis')?.value || '20-50';
    const r = await fetch(`/api/analyze/${encodeURIComponent(ticker)}?range=${encodeURIComponent(range)}&mabasis=${maBasis}`);
    const j = await r.json();
    if(!j.ok) throw new Error(j.error||'API error');

    const { metrics, plan, candles } = j;
    lastMetrics = metrics;
    lastCandles = candles.slice(-140);
    lastFib = plan.fib;
    $('#panel').classList.remove('d-none');
    $('#title').textContent = `${j.ticker} ‚Ä¢ ${metrics.trend_emoji} ${metrics.trend}`;
    // Show selected range in badge
    document.querySelector('#panel .badge').textContent = range.toUpperCase();
    document.getElementById('tfBadge').textContent = range.toUpperCase();
    const headerMABasis = document.getElementById('headerMABasis');
    if(headerMABasis) headerMABasis.textContent = metrics.ma_basis;
    document.getElementById('price').textContent = fmt(metrics.last_close);
    $('#trend').textContent = metrics.trend;
    $('#rsi').textContent = fmt(metrics.rsi);
    $('#cci').textContent = fmt(metrics.cci,1);
    $('#atr').textContent = fmt(metrics.atr);
    $('#atrpct').textContent = pct(metrics.atr_pct);
    $('#vold').textContent = pct(metrics.vol_delta,1);
    $('#earn').textContent = metrics.earnings_str;

    $('#bias').textContent = plan.bias + ' ' + plan.stars;
    $('#entry').textContent = fmt(plan.entry);
    $('#sl').textContent = fmt(plan.sl);
    $('#tp1').textContent = fmt(plan.tp1);
    $('#tp2').textContent = fmt(plan.tp2);

    const fibDiv = $('#fibs'); fibDiv.innerHTML='';
    Object.entries(plan.fib).forEach(([k,v])=>{
      const d=document.createElement('div'); d.textContent = `${k}: ${fmt(v)}`; fibDiv.appendChild(d);
    });

    // Color classes
    ['rsi','atrpct','vold'].forEach(id=>{ const el=$('#'+id); el.classList.remove('metric-good','metric-warn','metric-bad'); });
    const rsiCls = classifyRSI(metrics.rsi); if(rsiCls) $('#rsi').classList.add(rsiCls);
    const atrpCls = classifyATRpct(metrics.atr_pct); if(atrpCls) $('#atrpct').classList.add(atrpCls);
    const volCls = classifyVol(metrics.vol_delta); if(volCls) $('#vold').classList.add(volCls);

    // Insight
    const insightText = buildInsight(metrics);
    const insEl = $('#insight');
    if(insightText){ insEl.textContent = insightText; insEl.classList.remove('d-none'); } else insEl.classList.add('d-none');

    const showChart = $('#showChart').checked;
    show($('#chartCard'), showChart);
    if(showChart){ drawChart($('#chart'), lastCandles, plan.fib); drawFlowFromSelection(); drawSRFromSelection(); updateFlowTitle(); }

  }catch(err){
    const a=$('#alert'); a.textContent = 'Error: ' + (err.message || err); a.classList.remove('d-none');
  }finally{
    $('#spin').classList.add('d-none');
  }
}

function drawChart(canvas, rows, fib){
  const ctx=canvas.getContext('2d');
  const W=canvas.width, H=canvas.height;
  ctx.clearRect(0,0,W,H);
  const padL=50, padR=10, padT=10, padB=32; // increase padB for date labels
  const xs=rows.length;
  const prices = rows.flatMap(r=>[r.h,r.l]);
  const minP=Math.min(...prices), maxP=Math.max(...prices);
  const x = i => padL + (i/(xs-1))*(W-padL-padR);
  const y = p => padT + (1-(p-minP)/(maxP-minP))*(H-padT-padB);

  // grid
  ctx.strokeStyle=getComputedStyle(document.body).getPropertyValue('--bs-border-color');
  ctx.lineWidth=1; ctx.setLineDash([3,3]); ctx.beginPath();
  for(let i=0;i<=4;i++){ const yy=padT + i*(H-padT-padB)/4; ctx.moveTo(padL,yy); ctx.lineTo(W-padR,yy); }
  ctx.stroke(); ctx.setLineDash([]);

  // candles
  for(let i=0;i<rows.length;i++){
    const r=rows[i]; const cx=x(i);
    const col = r.c>=r.o ? '#198754' : '#dc3545';
    ctx.strokeStyle=col; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(cx,y(r.l)); ctx.lineTo(cx,y(r.h)); ctx.stroke();
    ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(cx,y(r.o)); ctx.lineTo(cx,y(r.c)); ctx.stroke();
  }

  // fib lines
  ctx.lineWidth=1; ctx.setLineDash([4,3]); ctx.strokeStyle='#6c757d';
  Object.entries(fib).forEach(([label,level])=>{
    const yy=y(level);
    ctx.beginPath(); ctx.moveTo(padL,yy); ctx.lineTo(W-padR,yy); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='#6c757d'; ctx.font='12px system-ui';
    ctx.fillText(label, padL+2, yy-2);
    ctx.setLineDash([4,3]);
  });

  // x-axis date labels
  ctx.font = '12px system-ui';
  ctx.fillStyle = '#444';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  const dateStep = Math.ceil(xs / 7); // 7 labels max
  
  // Get current range to determine date format
  const currentRange = document.getElementById('range')?.value || '1d';
  
  for(let i=0;i<xs;i+=dateStep){
    const r = rows[i];
    let dateStr = '';
    if(r.t){
      const ts = r.t > 1e12 ? r.t : r.t*1000;
      const d = new Date(ts);
      
      // Format based on timeframe
      if (currentRange === '5m' || currentRange === '15m') {
        dateStr = d.toTimeString().slice(0,5); // HH:MM
      } else if (currentRange === '1h') {
        dateStr = d.toTimeString().slice(0,5); // HH:MM
      } else if (currentRange === '1w') {
        dateStr = d.toISOString().slice(0,10); // YYYY-MM-DD
      } else {
        dateStr = d.toISOString().slice(5,10); // MM-DD
      }
    } else if(r.date){
      dateStr = r.date.length > 6 ? r.date.slice(5,10) : r.date;
    } else {
      dateStr = String(i);
    }
    ctx.fillText(dateStr, x(i), H-padB+4);
  }
  
  // Always show last date
  if(xs>0){
    const r = rows[xs-1];
    let dateStr = '';
    if(r.t){
      const ts = r.t > 1e12 ? r.t : r.t*1000;
      const d = new Date(ts);
      
      if (currentRange === '5m' || currentRange === '15m') {
        dateStr = d.toTimeString().slice(0,5);
      } else if (currentRange === '1h') {
        dateStr = d.toTimeString().slice(0,5);
      } else if (currentRange === '1w') {
        dateStr = d.toISOString().slice(0,10);
      } else {
        dateStr = d.toISOString().slice(5,10);
      }
    } else if(r.date){
      dateStr = r.date.length > 6 ? r.date.slice(5,10) : r.date;
    } else {
      dateStr = String(xs-1);
    }
    ctx.fillText(dateStr, x(xs-1), H-padB+4);
  }
}

// === Flow metric calculations & rendering ===
function computeOBV(candles){
  let obv=[]; let cur=0; for(let i=0;i<candles.length;i++){ if(i>0){ const prev=candles[i-1]; const c=candles[i]; if(c.c>prev.c) cur+=c.v; else if(c.c<prev.c) cur-=c.v; } obv.push(cur);} return obv; }
function computeMFI(candles, period=14){
  const tp = candles.map(c=>(c.h+c.l+c.c)/3);
  const mf = tp.map((t,i)=> t * candles[i].v);
  let mfi=[]; for(let i=0;i<candles.length;i++){ if(i<period) { mfi.push(null); continue; } let pos=0,neg=0; for(let j=i-period+1;j<=i;j++){ if(tp[j]>tp[j-1]) pos+=mf[j]; else if(tp[j]<tp[j-1]) neg+=mf[j]; }
    const ratio = neg===0?100: pos===0?0: 100 - (100/(1+ (pos/neg)));
    mfi.push(ratio); }
  return mfi; }
function computeCMF(candles, period=20){
  let cmf=[]; for(let i=0;i<candles.length;i++){ if(i<period){ cmf.push(null); continue; }
    let mfvSum=0, volSum=0; for(let j=i-period+1;j<=i;j++){ const c=candles[j]; const hl = c.h - c.l || 1e-9; const mfm = ((c.c - c.l) - (c.h - c.c)) / hl; const mfv = mfm * c.v; mfvSum += mfv; volSum += c.v; }
    cmf.push(mfvSum / volSum); }
  return cmf; }
function computeSRLevels(candles, opts={}) {
  if(!candles || candles.length < 20) return [];
  const rangeSel = document.getElementById('range')?.value || '1d';
  // Use deeper history for better S/R derivation
  let histBars;
  if (rangeSel === '5m') histBars = 600;           // ~2 trading days
  else if (rangeSel === '15m') histBars = 900;      // ~2+ weeks intraday
  else if (rangeSel === '1h') histBars = 900;       // ~5-6 weeks
  else if (rangeSel === '1d') histBars = 260;       // ~1 trading year
  else histBars = 400;                              // weekly ~7+ years max fallback
  const src = candles.slice(-histBars);

  // Dynamic pivot width relative to dataset length
  const n = src.length;
  const baseWin = rangeSel==='1d' ? 3 : 2; // smaller on intraday
  const pivotLeft = Math.max(baseWin, Math.floor(n/120));
  const pivotRight = pivotLeft; // symmetric window

  // Collect raw pivot points
  const pivots = [];
  for (let i=pivotLeft; i < n - pivotRight; i++) {
    let isHigh = true, isLow = true;
    const c = src[i];
    for (let k=1;k<=pivotLeft;k++) {
      if (src[i-k].h > c.h || src[i+k].h > c.h) isHigh = false;
      if (src[i-k].l < c.l || src[i+k].l < c.l) isLow = false;
      if(!isHigh && !isLow) break;
    }
    if (isHigh) pivots.push({price:c.h, type:'resistance', vol:c.v||0, idx:i});
    if (isLow) pivots.push({price:c.l, type:'support', vol:c.v||0, idx:i});
  }
  if(!pivots.length) return [];

  // Initial merge tolerance (% of price). Tighter than before for finer clustering.
  const pricesAll = pivots.map(p=>p.price);
  const minP = Math.min(...pricesAll), maxP = Math.max(...pricesAll);
  const priceRange = maxP - minP || 1;
  const tolPct = 0.004; // 0.4%
  const tolerance = priceRange * tolPct;

  // Sort by price then merge close pivots into clusters
  pivots.sort((a,b)=>a.price-b.price);
  const clusters = [];
  for (const p of pivots) {
    let found = clusters.find(cl => Math.abs(cl.center - p.price) <= tolerance);
    if (found) {
      found.points.push(p);
      // weighted center by touches (point count) and volume
      const wOld = found.points.length - 1;
      const wNew = 1;
      found.center = (found.center * wOld + p.price * wNew)/(wOld + wNew);
      if (p.type==='support') found.supportCount++; else found.resCount++;
      found.totalVol += p.vol || 0;
      found.lastIdx = Math.max(found.lastIdx, p.idx);
      found.firstIdx = Math.min(found.firstIdx, p.idx);
    } else {
      clusters.push({
        center: p.price,
        points: [p],
        supportCount: p.type==='support'?1:0,
        resCount: p.type==='resistance'?1:0,
        totalVol: p.vol||0,
        firstIdx: p.idx,
        lastIdx: p.idx
      });
    }
  }

  // Score clusters: touches + volume weight + recency weight + balance bonus
  const lastIndex = n-1;
  clusters.forEach(cl => {
    const touches = cl.points.length;
    const volNorm = cl.totalVol / (1 + Math.max(...clusters.map(c=>c.totalVol))) * 2; // 0..2
    const recency = 1 - (lastIndex - cl.lastIdx)/ (lastIndex || 1); // 0 recent ..1 very recent
    const balance = (cl.supportCount>0 && cl.resCount>0) ? 1 : 0; // acted as both sides
    cl.score = touches * 2 + volNorm + recency * 1.5 + balance * 1.2;
  });

  // Deduplicate overlapping high-score clusters enforcing minimum spacing
  clusters.sort((a,b)=> b.score - a.score);
  const final = [];
  const minSpacing = priceRange * 0.018; // 1.8% spacing
  for (const cl of clusters) {
    if (final.some(f=> Math.abs(f.level - cl.center) < minSpacing)) continue;
    final.push({
      level: cl.center,
      touches: cl.points.length,
      score: +cl.score.toFixed(3),
      type: cl.supportCount >= cl.resCount ? 'support':'resistance'
    });
    if (final.length >= (opts.maxLevels || 6)) break;
  }

  // Ensure we include a level near current price if none within 1% (helps match examples)
  const lastClose = src[n-1].c;
  if(!final.some(l => Math.abs(l.level - lastClose)/lastClose < 0.01)) {
    final.push({level:lastClose, touches:1, score:0.5, type:'price'});
  }
  // Sort descending for drawing (top to bottom visually optional)
  return final.sort((a,b)=> b.level - a.level);
}
// ...existing code...
function drawSRChart(canvas, candles){
  const ctx=canvas.getContext('2d'); const W=canvas.width, H=canvas.height; ctx.clearRect(0,0,W,H); if(!candles||!candles.length) return;
  const srLevels = computeSRLevels(candles);
  
  // Use more recent data for cleaner chart
  const currentRange = document.getElementById('range')?.value || '1d';
  let displayBars;
  if (currentRange === '5m') displayBars = Math.min(candles.length, 200); // show more for context
  else if (currentRange === '15m') displayBars = Math.min(candles.length, 400);  
  else if (currentRange === '1h') displayBars = Math.min(candles.length, 500);
  else if (currentRange === '1d') displayBars = Math.min(candles.length, 180); // extended history for daily like example
  else displayBars = Math.min(candles.length, 260); // ~1 month for weekly data
  
  const displayCandles = candles.slice(-displayBars);
  const prices = displayCandles.map(c=>c.c); 
  
  // Expand price range to include all S/R levels
  const srPrices = srLevels.map(sr => sr.level);
  const allPrices = [...prices, ...srPrices];
  const minP = Math.min(...allPrices);
  const maxP = Math.max(...allPrices);
  const priceRange = maxP - minP;
  const padding = priceRange * 0.08; // 8% padding for better visibility
  const chartMinP = minP - padding;
  const chartMaxP = maxP + padding;
  
  const padL=60,padR=15,padT=15,padB=25; const n=displayCandles.length; 
  const x=i=> padL + (i/(n-1))*(W-padL-padR); 
  const y=p=> padT + (1-(p-chartMinP)/(chartMaxP-chartMinP||1))*(H-padT-padB);
  
  // Clean background
  ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,W,H);
  
  // Price grid lines (horizontal)
  ctx.strokeStyle='#f0f0f0'; ctx.lineWidth=1; 
  const gridSteps = 8;
  for(let i=0; i<=gridSteps; i++){
    const gridPrice = chartMinP + (i/gridSteps) * (chartMaxP - chartMinP);
    const yy = y(gridPrice);
    ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(W-padR, yy); ctx.stroke();
  }
  
  // Price line (prominent blue like the example)
  ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle='#2196F3'; let started=false;
  for(let i=0;i<n;i++){ 
    const p=prices[i], xx=x(i), yy=y(p); 
    if(!started){ctx.moveTo(xx,yy);started=true;} else ctx.lineTo(xx,yy);
  } 
  ctx.stroke();
  
  // S/R levels - solid horizontal lines like the example
  srLevels.forEach((sr,idx)=>{
    const yy=y(sr.level); 
    const isResistance = sr.type === 'resistance';
    const color = isResistance ? '#E53E3E' : '#38A169'; // Clean red/green like example
    
    ctx.strokeStyle = color; 
    ctx.lineWidth = 1.5; // Clean solid line thickness
    ctx.setLineDash([]); // Solid lines, no dashing
    ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(W-padR, yy); ctx.stroke();
    
    // Price level labels on left side
    ctx.fillStyle = color; 
    ctx.font = '11px system-ui'; 
    ctx.textAlign = 'right'; 
    ctx.textBaseline = 'middle';
    ctx.fillText(`${sr.level.toFixed(2)}`, padL-5, yy);
  });
  
  // Y-axis price labels (left side)
  ctx.fillStyle='#666'; ctx.font='10px system-ui'; ctx.textAlign='right'; ctx.textBaseline='middle';
  for(let i=0; i<=4; i++){
    const labelPrice = chartMinP + (i/4) * (chartMaxP - chartMinP);
    const yy = y(labelPrice);
    ctx.fillText(labelPrice.toFixed(2), padL-25, yy);
  }
  
  // Left axis line
  ctx.strokeStyle='#ddd'; ctx.lineWidth=1; 
  ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, H-padB); ctx.stroke();
  
  // Title
  ctx.fillStyle='#333'; ctx.font='14px system-ui'; ctx.textAlign='left'; ctx.textBaseline='top'; 
  ctx.fillText('S/R Levels', padL+4, 4);
}
function drawFlowChart(canvas, candles, metric){
  const ctx=canvas.getContext('2d'); const W=canvas.width, H=canvas.height; ctx.clearRect(0,0,W,H); if(!candles||!candles.length) return;
  let data; let min,max; let type=metric;
  if(metric==='OBV'){ data=computeOBV(candles); min=Math.min(...data); max=Math.max(...data); }
  else if(metric==='MFI'){ data=computeMFI(candles); data=data.map(v=>v==null?null:+v); min=0; max=100; }
  else { data=computeCMF(candles); min=-1; max=1; }
  if(max===min){ max=min+1; }
  const padL=50,padR=10,padT=8,padB=20; const n=data.length; const x=i=> padL + (i/(n-1))*(W-padL-padR); const y=v=> padT + (1-(v-min)/(max-min))*(H-padT-padB);
  ctx.fillStyle='#fafafa'; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle='#e0e0e0'; ctx.lineWidth=1; ctx.setLineDash([4,3]); ctx.beginPath(); const gSteps=4; for(let i=0;i<=gSteps;i++){ const yy=padT + i*(H-padT-padB)/gSteps; ctx.moveTo(padL,yy); ctx.lineTo(W-padR,yy);} ctx.stroke(); ctx.setLineDash([]);
  if(metric==='MFI'){ [20,50,80].forEach(level=>{ const yy=y(level); ctx.strokeStyle= level===50?'#999':'#bbb'; ctx.beginPath(); ctx.moveTo(padL,yy); ctx.lineTo(W-padR,yy); ctx.stroke(); }); }
  if(metric==='CMF'){ const zeroY=y(0); ctx.strokeStyle='#999'; ctx.beginPath(); ctx.moveTo(padL,zeroY); ctx.lineTo(W-padR,zeroY); ctx.stroke(); }
  ctx.beginPath(); let started=false; ctx.lineWidth=2; ctx.strokeStyle= metric==='OBV'? '#0d6efd': metric==='MFI'? '#6f42c1':'#fd7e14';
  for(let i=0;i<n;i++){ const v=data[i]; if(v==null) continue; const xx=x(i), yy=y(v); if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy); }
  ctx.stroke();
  const prices = candles.map(c=>c.c); const pMin=Math.min(...prices), pMax=Math.max(...prices);
  const priceNorm = prices.map(p=> min + ((p - pMin)/(pMax - pMin || 1)) * (max - min));
  ctx.beginPath(); started=false; ctx.lineWidth=1.25; ctx.strokeStyle='#444'; ctx.setLineDash([6,3]);
  for(let i=0;i<n;i++){ const v=priceNorm[i]; const xx=x(i), yy=y(v); if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);} ctx.stroke(); ctx.setLineDash([]);
  ctx.strokeStyle='#444'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, H-padB); ctx.stroke();
  ctx.fillStyle='#666'; ctx.font='11px system-ui'; ctx.textAlign='right'; ctx.textBaseline='middle';
  const labelVals=[min, min+(max-min)/2, max]; labelVals.forEach(val=>{ const yy=y(val); ctx.fillText(val.toFixed(metric==='OBV'?0: metric==='MFI'?0:2), padL-4, yy); });
  ctx.font='12px system-ui'; ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillStyle= metric==='OBV'? '#0d6efd': metric==='MFI'? '#6f42c1':'#fd7e14'; ctx.fillText(type, padL+4, 4);
  ctx.fillStyle='#444'; ctx.fillText('Price (norm)', padL+60, 4);
}
// ...existing code...
function drawSRChart(canvas, candles){
  const ctx=canvas.getContext('2d'); const W=canvas.width, H=canvas.height; ctx.clearRect(0,0,W,H); if(!candles||!candles.length) return;
  const srLevels = computeSRLevels(candles);
  
  // Use more recent data for cleaner chart
  const currentRange = document.getElementById('range')?.value || '1d';
  let displayBars;
  if (currentRange === '5m') displayBars = Math.min(candles.length, 200); // show more for context
  else if (currentRange === '15m') displayBars = Math.min(candles.length, 400);  
  else if (currentRange === '1h') displayBars = Math.min(candles.length, 500);
  else if (currentRange === '1d') displayBars = Math.min(candles.length, 180); // extended history for daily like example
  else displayBars = Math.min(candles.length, 260); // ~1 month for weekly data
  
  const displayCandles = candles.slice(-displayBars);
  const prices = displayCandles.map(c=>c.c); 
  
  // Expand price range to include all S/R levels
  const srPrices = srLevels.map(sr => sr.level);
  const allPrices = [...prices, ...srPrices];
  const minP = Math.min(...allPrices);
  const maxP = Math.max(...allPrices);
  const priceRange = maxP - minP;
  const padding = priceRange * 0.08; // 8% padding for better visibility
  const chartMinP = minP - padding;
  const chartMaxP = maxP + padding;
  
  const padL=60,padR=15,padT=15,padB=25; const n=displayCandles.length; 
  const x=i=> padL + (i/(n-1))*(W-padL-padR); 
  const y=p=> padT + (1-(p-chartMinP)/(chartMaxP-chartMinP||1))*(H-padT-padB);
  
  // Clean background
  ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,W,H);
  
  // Price grid lines (horizontal)
  ctx.strokeStyle='#f0f0f0'; ctx.lineWidth=1; 
  const gridSteps = 8;
  for(let i=0; i<=gridSteps; i++){
    const gridPrice = chartMinP + (i/gridSteps) * (chartMaxP - chartMinP);
    const yy = y(gridPrice);
    ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(W-padR, yy); ctx.stroke();
  }
  
  // Price line (prominent blue like the example)
  ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle='#2196F3'; let started=false;
  for(let i=0;i<n;i++){ 
    const p=prices[i], xx=x(i), yy=y(p); 
    if(!started){ctx.moveTo(xx,yy);started=true;} else ctx.lineTo(xx,yy);
  } 
  ctx.stroke();
  
  // S/R levels - solid horizontal lines like the example
  srLevels.forEach((sr,idx)=>{
    const yy=y(sr.level); 
    const isResistance = sr.type === 'resistance';
    const color = isResistance ? '#E53E3E' : '#38A169'; // Clean red/green like example
    
    ctx.strokeStyle = color; 
    ctx.lineWidth = 1.5; // Clean solid line thickness
    ctx.setLineDash([]); // Solid lines, no dashing
    ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(W-padR, yy); ctx.stroke();
    
    // Price level labels on left side
    ctx.fillStyle = color; 
    ctx.font = '11px system-ui'; 
    ctx.textAlign = 'right'; 
    ctx.textBaseline = 'middle';
    ctx.fillText(`${sr.level.toFixed(2)}`, padL-5, yy);
  });
  
  // Y-axis price labels (left side)
  ctx.fillStyle='#666'; ctx.font='10px system-ui'; ctx.textAlign='right'; ctx.textBaseline='middle';
  for(let i=0; i<=4; i++){
    const labelPrice = chartMinP + (i/4) * (chartMaxP - chartMinP);
    const yy = y(labelPrice);
    ctx.fillText(labelPrice.toFixed(2), padL-25, yy);
  }
  
  // Left axis line
  ctx.strokeStyle='#ddd'; ctx.lineWidth=1; 
  ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, H-padB); ctx.stroke();
  
  // Title
  ctx.fillStyle='#333'; ctx.font='14px system-ui'; ctx.textAlign='left'; ctx.textBaseline='top'; 
  ctx.fillText('S/R Levels', padL+4, 4);
}
function drawFlowFromSelection(){ const metric = document.getElementById('flowMetric')?.value||'OBV'; const canvas=document.getElementById('flowChart'); if(canvas && lastCandles) drawFlowChart(canvas,lastCandles,metric); }
function drawSRFromSelection(){ const canvas=document.getElementById('srChart'); if(canvas && lastCandles) drawSRChart(canvas,lastCandles); }
const flowSel=document.getElementById('flowMetric'); if(flowSel){ flowSel.addEventListener('change', ()=> { updateFlowTitle(); drawFlowFromSelection(); }); }
// Redraw flow if chart toggled on
const showChartEl = document.getElementById('showChart'); if(showChartEl){ showChartEl.addEventListener('change', ()=>{ if(showChartEl.checked){ drawFlowFromSelection(); drawSRFromSelection(); } }); }
// =============================================

document.querySelector('#form').addEventListener('submit', (e)=>{
  e.preventDefault();
  const t = document.querySelector('#ticker').value.trim();
  if(!t) return;
  showBox(false);
  analyze(t.toUpperCase());
});

document.querySelector('#savePng').addEventListener('click', ()=>{
  const c=document.querySelector('#chart');
  const a=document.createElement('a'); a.href=c.toDataURL('image/png'); a.download='chart.png'; a.click();
});

function copyChartToClone(cloneCard) {
  const origCanvases = document.querySelectorAll('#chartCard canvas');
  const cloneCanvases = cloneCard.querySelectorAll('canvas');
  origCanvases.forEach((orig, idx)=>{
    const clone = cloneCanvases[idx]; if(!clone) return;
    clone.width = orig.width; clone.height = orig.height;
    clone.getContext('2d').drawImage(orig,0,0);
  });
}

// Add missing showToast function
function showToast(message, type = 'primary') {
  const toast = document.getElementById('mainToast');
  const toastMsg = document.getElementById('toastMsg');
  if (!toast || !toastMsg) return;
  
  toastMsg.textContent = message;
  toast.className = `toast align-items-center border-0 ${type === 'success' ? 'text-bg-success' : type === 'danger' ? 'text-bg-danger' : 'text-bg-primary'}`;
  
  const bsToast = new bootstrap.Toast(toast);
  bsToast.show();
}

// Backtest logic
const backtestBtn = document.getElementById('backtestBtn');
if (backtestBtn){
  backtestBtn.addEventListener('click', async ()=>{
    const t = tickerEl.value.trim();
    if(!t){ showToast('Enter ticker first','danger'); return; }
    backtestBtn.disabled = true; backtestBtn.textContent = 'Testing...';
    try {
      const range = document.getElementById('range').value;
      const maBasis = document.getElementById('maBasis')?.value || '20-50';
      const r = await fetch(`/api/backtest/${encodeURIComponent(t)}?range=${encodeURIComponent(range)}&mabasis=${maBasis}`);
      const j = await r.json();
      if(!j.ok) throw new Error(j.error||'Backtest failed');
      const s = j.stats;
      const statsLine = `Setups: ${s.setups} ‚Ä¢ Wins: ${s.wins} ‚Ä¢ Losses: ${s.losses} ‚Ä¢ No Exit: ${s.noExit} ‚Ä¢ WinRate: ${s.winRate}% (Resolved: ${s.resolvedWinRate}%) <button id="toggleBTAdv" class="btn btn-link btn-sm p-0 ms-2">Advanced</button>`; 
      const extraLine = `Expectancy: ${s.expectancy}R ‚Ä¢ PF: ${s.profitFactor} ‚Ä¢ MaxDD: ${s.maxDrawdownR}R ‚Ä¢ Final: ${s.finalR}R ‚Ä¢ AvgBars W/L: ${s.avgBarsWin}/${s.avgBarsLoss} ‚Ä¢ MA:${s.ma_basis}`;
      document.getElementById('btStats').innerHTML = `<div>${statsLine}</div><div id="btAdv" class="text-secondary small mt-1 d-none">${extraLine}</div>`;
      const rowsHtml = (j.samples||[]).map(r=>`<tr><td>${r.date||''}</td><td>${fmt(r.entry)}</td><td>${fmt(r.target)}</td><td>${fmt(r.stop)}</td><td class="${r.outcome==='WIN'?'text-success':r.outcome==='LOSS'?'text-danger':'text-muted'}">${r.outcome}</td></tr>`).join('');
      document.getElementById('btRows').innerHTML = rowsHtml || '<tr><td colspan="5" class="text-center text-muted">No samples</td></tr>';
      document.getElementById('btSection').classList.remove('d-none');
      // expectancy badge
      const expBadge = document.getElementById('expBadge');
      const expVal = parseFloat(s.expectancy);
      if(Number.isFinite(expVal)){
        expBadge.textContent = `Exp ${expVal.toFixed(2)}R`;
        expBadge.className = 'badge ' + (expVal>0? 'text-bg-success' : expVal<0? 'text-bg-danger':'text-bg-secondary');
        expBadge.classList.remove('d-none');
      }
      const tog=document.getElementById('toggleBTAdv'); if(tog){ tog.addEventListener('click',()=>{ document.getElementById('btAdv').classList.toggle('d-none'); }); }
      showToast('Backtest done','success');
    } catch(e){
      showToast(e.message,'danger');
    } finally {
      backtestBtn.disabled = false; backtestBtn.textContent = 'Backtest Fib';
    }
  });
}

// Position sizing helper
document.addEventListener('click',e=>{
  if(e.target&& e.target.id==='calcSize'){
    const risk = parseFloat($('#riskUsd').value||'');
    const entryV = parseFloat($('#entry').textContent);
    const slV = parseFloat($('#sl').textContent);
    if(!risk || !Number.isFinite(entryV) || !Number.isFinite(slV)) { $('#sizeOut').textContent=''; return; }
    const perShare = Math.abs(entryV - slV);
    if(perShare<=0){ $('#sizeOut').textContent=''; return; }
    const shares = Math.floor(risk / perShare);
    $('#sizeOut').textContent = shares>0?`~${shares} shares (risk/share ${perShare.toFixed(2)})`:'Risk too small';
  }
});

// Ensure flow chart is rendered before download/copy
function ensureFlowReady(){
  const flowCanvas=document.getElementById('flowChart');
  if(flowCanvas && lastCandles){ drawFlowFromSelection(); }
  const srCanvas=document.getElementById('srChart');
  if(srCanvas && lastCandles){ drawSRFromSelection(); }
}
// Modify download handler to ensure flow chart rendered
const dlBtn=document.getElementById('downloadImg');
if(dlBtn){
  dlBtn.addEventListener('click', async () => {
    ensureFlowReady();
    // Offscreen desktop-like wrapper to avoid mobile wrapping issues
    const wrapper = document.createElement('div');
    wrapper.style.position='fixed';
    wrapper.style.left='-2000px';
    wrapper.style.top='0';
    wrapper.style.width='1280px';
    wrapper.style.display='flex';
    wrapper.style.flexDirection='row';
    wrapper.style.flexWrap='nowrap';
    wrapper.style.alignItems='flex-start';
    wrapper.style.gap='20px';
    wrapper.style.padding='20px';
    wrapper.style.background='#ffffff';
    wrapper.style.border='1px solid #ddd';
    wrapper.style.boxSizing='border-box';
    wrapper.style.fontFamily='system-ui,-apple-system,Segoe UI,Roboto,sans-serif';

    const panelOrig=document.getElementById('panel');
    const chartOrig=document.getElementById('chartCard');
    if(!panelOrig || !chartOrig){ return; }
    const panelClone=panelOrig.cloneNode(true); panelClone.classList.remove('d-none');
    panelClone.style.flex='0 0 360px'; panelClone.style.maxWidth='360px'; panelClone.style.minWidth='360px';
    const chartClone=chartOrig.cloneNode(true); chartClone.classList.remove('d-none'); chartClone.style.flex='1 1 auto';

    // Sync canvases
    copyChartToClone(chartClone);

    wrapper.appendChild(panelClone);
    wrapper.appendChild(chartClone);
    document.body.appendChild(wrapper);

    try {
      const canvas = await html2canvas(wrapper, {
        backgroundColor:'#ffffff',
        scale: Math.min(2, window.devicePixelRatio || 1.5),
        useCORS:true,
        logging:false,
        width: wrapper.offsetWidth,
        height: wrapper.offsetHeight,
        windowWidth: wrapper.offsetWidth,
        windowHeight: wrapper.offsetHeight
      });
      const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='stock-analysis.png'; a.click();
    } catch(err){
      console.error('Download render failed', err);
      showToast('Image render failed','danger');
    } finally {
      document.body.removeChild(wrapper);
    }
  });
}
// Modify copy handler similarly
const copyBtn=document.getElementById('copyImg');
if(copyBtn){ copyBtn.addEventListener('click', async () => {
  ensureFlowReady();
  const container = document.createElement('div');
  container.style.display = 'flex';
  container.style.gap = '16px';
  container.style.background = '#fff';
  container.style.padding = '16px';
  const panelClone = document.getElementById('panel').cloneNode(true);
  const chartCardClone = document.getElementById('chartCard').cloneNode(true);
  copyChartToClone(chartCardClone);
  container.appendChild(panelClone);
  container.appendChild(chartCardClone);
  document.body.appendChild(container);
  html2canvas(container,{backgroundColor:'#fff'}).then(async canvas=>{
    canvas.toBlob(async blob=>{
      try{ await navigator.clipboard.write([ new ClipboardItem({'image/png':blob}) ]); showToast('Copied to clipboard!','success'); }
      catch(e){ showToast('Copy failed: '+e,'danger'); }
      document.body.removeChild(container);
    });
  });
}); }

// Chart modal logic (updated: separate modals)
function openPriceModal(){
  if(!lastCandles) return; const modalEl=document.getElementById('priceModal'); if(!modalEl) return;
  const c=document.getElementById('priceModalCanvas'); if(c){ drawChart(c,lastCandles,lastFib||{}); }
  const meta=document.getElementById('priceModalMeta'); if(meta && lastMetrics){ meta.textContent=`${lastTicker||''} ‚Ä¢ Trend: ${lastMetrics.trend} ‚Ä¢ Price: ${fmt(lastMetrics.last_close)} ‚Ä¢ ATR%: ${pct(lastMetrics.atr_pct)} ‚Ä¢ VolŒî: ${pct(lastMetrics.vol_delta)}`; }
  bootstrap.Modal.getOrCreateInstance(modalEl).show();
}
function openFlowModal(){
  if(!lastCandles) return; const modalEl=document.getElementById('flowModal'); if(!modalEl) return;
  const c=document.getElementById('flowModalCanvas'); if(c){ drawFlowChart(c,lastCandles, document.getElementById('flowMetric')?.value||'OBV'); }
  bootstrap.Modal.getOrCreateInstance(modalEl).show();
}
function openSRModal(){
  if(!lastCandles) return; const modalEl=document.getElementById('srModal'); if(!modalEl) return;
  const c=document.getElementById('srModalCanvas'); if(c){ drawSRChart(c,lastCandles); }
  bootstrap.Modal.getOrCreateInstance(modalEl).show();
}
// Attach listeners
const mainPriceCanvas=document.getElementById('chart'); if(mainPriceCanvas){ mainPriceCanvas.style.cursor='zoom-in'; mainPriceCanvas.addEventListener('click', openPriceModal); }
const mainFlowCanvas=document.getElementById('flowChart'); if(mainFlowCanvas){ mainFlowCanvas.style.cursor='zoom-in'; mainFlowCanvas.addEventListener('click', openFlowModal); }
const mainSRCanvas=document.getElementById('srChart'); if(mainSRCanvas){ mainSRCanvas.style.cursor='zoom-in'; mainSRCanvas.addEventListener('click', openSRModal); }
// Save buttons
const priceModalSave=document.getElementById('priceModalSave'); if(priceModalSave){ priceModalSave.addEventListener('click',()=>{ const canvas=document.getElementById('priceModalCanvas'); if(!canvas) return; const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='price-chart.png'; a.click(); }); }
const flowModalSave=document.getElementById('flowModalSave'); if(flowModalSave){ flowModalSave.addEventListener('click',()=>{ const canvas=document.getElementById('flowModalCanvas'); if(!canvas) return; const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='flow-chart.png'; a.click(); }); }
const srModalSave=document.getElementById('srModalSave'); if(srModalSave){ srModalSave.addEventListener('click',()=>{ const canvas=document.getElementById('srModalCanvas'); if(!canvas) return; const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='sr-chart.png'; a.click(); }); }
// Add missing updateFlowTitle definition
function updateFlowTitle(){
  const metric = document.getElementById('flowMetric')?.value || 'OBV';
  const el = document.getElementById('flowTitle');
  if(el) el.textContent = `Flow: ${metric} + Price`;
}
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</body>
</html>
